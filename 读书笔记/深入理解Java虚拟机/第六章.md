# 第六章——类文件结构

Java 虚拟机不和包括 Java 在内地任何语言绑定，它只与 “Class文件” 这种特殊的二进制格式所关联，Class 文件中包含了 Java 虚拟机指令集和符号表以及若干辅助信息。

## Class 类文件的结构

任何一个 Class 文件都对应着唯一一个类或接口的定义信息，但反过来说，类或接口并不一定都得定义在文件里（譬如类或接口也可以通过类加载器直接生成）。

Class 文件是一组以 8 位字节为基础单位得二进制流，各个数据项目严格按照顺序紧凑地排列在 Class 文件之中，中间没有添加任何分隔符，这使得整个 Class 文件存储得数据都是程序运行时得必要数据，没有空隙存在。当遇到需要占用 8 位字节以上空间得数据项时，则会按照高位在前得方式分割成若干个 8 位字节进行存储。

Class 文件中只有两种数据结构：无符号数和表。

* 无符号数属于基本的数据类型，以 u1，u2，u4，u8来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值

* 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有的表都习惯性得以 “_info” 结尾。表用于描述有层次关系的复合结构的数据，整个 Class 文件本质上就是一张表。

无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容器计数器加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据为某一类型的集合。

### 魔数与 Class 文件的版本

每个 Class 文件的头 4 个字节称为魔数（Magic Number），它唯一的作用就是确定这个文件是否为一个能被虚  拟机接收的 Class 文件。很多文件存储标准都使用魔数进行身份识别，譬如图片格式，如 gif 或 jpeg 等在文件头中都存有魔数。

Class 文件的魔数值为 0xCAFEBABE。

紧接着魔数的 4 个字节存储的是 Class 文件的版本号：第 5 个和第 6 个是次版本号，第 7 个和第 8 个字节是主版本号。Java 的版本号是从 45 开始的，JDK 1.1 之后的每个 JDK 大版本发布主版本号向上加 1，高版本的 JDK 能向下兼容以前版本的 Class 文件。

### 常量池

紧接着主次版本号之后是常量池入口，常量池可以理解为 Class 文件之中的资源仓库，它是 Class 文件结构中与其他项目关联最多的数据类型，也是占用 Class 文件控件最大的数据项目之一，同时也是 Class 文件中第一个出现的表类型的数据项目。

由于常量池的数量是不固定的，所以在常量池的入口需要放置一项 u2 类型的数据，代表常量池容量计数值。这个容量计数是从 1 开始的。

常量池中主要存放两大类常量：字面量和符号引用。符号引用则属于编译原理方面的概念，包括下面三类常量：

* 类和接口的全限定名
* 字段的名称和描述符
* 方法的名称和描述符

Java 代码在进行 Javac 编译的时候，在虚拟机加载 Class 文件的时候进行动态连接。

在 Class 文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存地址，也就是无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。

分析 Class 文件字节码：`javap - verbose <ClassFile>`

### 访问标志

在常量池结束之后，紧接着的两个字节代表访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息额，包括：这个 Class 是类还是接口；是否定义为 public 类型；是否定义为 abstract 类型；如果是类的话，是否被声明为 final 等。

### 类索引、父类索引与接口索引集合

类索引和父类索引都是一个 u2 类型的数据，而接口索引集合是一组 u2 类型的数据的集合，Class 文件中由这三项数据来确定这个类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。

### 字段表集合

字段表用于描述接口胡总和类中声明的变量。字段包括类级变量以及实例级变量，但是不包括方法内部声明的局部变量。

字段表集合中不会列出从超类或者父类接口中继承的字段，但有可能列出原本 Java 代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。另外，在 Java 语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名是合法的。

### 方法表集合

Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式，方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。

方法里的 Java 代码，通过编译器编译成字节码指令后，存放在方法属性表集合中一个名为 “Code” 的属性里面，属性表作为 Class 文件格式中最具扩展性的一种数据项目。

与字段表集合相对应的，如果父类方法在子类中没有被重写，方法表集合中就不会出现来自父类的方法信息。但同样的，有可能出现由编译器自动添加的方法，最典型的就是类构造器 “<clinit>” 方法和实例构造器 “<init>” 方法。

### 属性表集合

1. Code 属性

  Java 程序方法体中的代码经过 Javac 编译器处理后，最终变成字节码指令存储在 Code 属性内。Code 属性出现在方法表的属性集合之中，但并非所有的方法表都必须存入这个属性，譬如接口或者抽象类中的方法就不存在 Code 属性。

2. Exceptions 属性

  列举出方法中可能抛出的受查异常，也就是方法描述时在 throws 关键字后面列举的异常。

3. LineNumberTable 属性

  用于描述 Java 源码行号与字节码之间的对应关系。它并不是运行时必需的属性，但默认会生成到 Class 文件之中。

4. LocalVariableTable 属性

  用于描述栈帧中局部变量表中的变量与 Java 源码中定义的变量之间的关系。可选。

5. SourceFile 属性

  用于记录生成这个 Class 文件的源码文件名称。可选。

6. ConstantValue 属性

  通知虚拟机自动为静态变量赋值。只有被 static 关键字修饰的变量（类变量）才可以使用这项属性。

  虚拟机为非 static 类型的变量（也就是实例变量）的赋值是在实例构造器 <init> 方法中进行的；而对于类变量，则有两种方式可以选择：在类构造器 <clinit> 方法中或者使用 ConstantValue 属性。

7. InnerClasses 属性

  记录内部类与宿主类之间的关联。

8. Deprecated 以及 Synthetic 属性

  Deprecated 和 Synthetic 这两个属性都属于标志类型的布尔属性，只存在有和没有的区别。

  Deprecated 用于标识某个类、字段或者方法，已经被程序作者定为不再推荐使用，可以通过 @deprecated 设置

  Synthetic 属性代表此字段不是由 Java 源码直接产生的，而是由编译器自行添加的。

9. StackMapTable 属性

  包含零至多个栈映射帧（Stack Map Frames），每个栈映射帧都显式或者隐式地代表了一个字节码偏移量，用于表示执行到该字节码时局部变量表和操作数栈的验证类型。

10. Signature 属性

  记录泛型签名信息。

  Java 的泛型采用的是擦除法实现的伪泛型。

11. BootstrapMethods 属性

  保存 invokedynameic 指令引用的引导方法限定符。
