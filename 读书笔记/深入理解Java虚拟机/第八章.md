# 第八章——虚拟机字节码执行引擎

从外观来看，所有 Java 虚拟机的执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。

## 运行时栈帧结构

栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机里面从入栈到出栈的方法。

在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表中的 Code 属性之中，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。

一个线程中的方法调用链可能会很长，很多方法都同时处于执行状态。对于执行引擎来说，在活动线程中，只有位于**栈顶**的栈帧才是有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作。

![栈帧的概念模型](../../Resources/stack_frame.jpg)

### 局部变量表

局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在 Java 程序编译为 Class 文件时，就在方法的 Code 属性的 max_locals 数据项中确定了该方法所需要分配的局部变量表的最大容量。

局部变量表的容量以变量槽（Variable Slot）为最小单位，每个 Slot 都应该能存放一个 boolean、byte、char、short、int、float、reference 或 returnAddress 类型的数据。

对于 64 位的数据，虚拟机会以高位对齐的方式为其分配两个连续的 Slot 空间。


虚拟机通过索引定位的方式使用局部变量表，索引范围是从 0 开始至局部变量表最大的 Slot 数量。32 bit -> n Slot, 64 bit -> n,n + 1 Slot。对于存放一个 64 位数据的两个 Slot，不允许采用任何方式单独访问其中一个。

在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果执行的是实例方法，那局部变量表中第 0 位索引的 Slot 默认是用于方法所属对象实例的引用，在方法中可以通过 this 访问到这个隐含的参数。其余参数则按照参数表顺序排列。参数表分配完成后，再根据方法体内部定义的变量顺序和作用域分配其余的 Slot。

局部变量表中的 Slot 是可以重用的，方法体定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码 PC 计数器的值已经超出了某个变量的作用域，那这个变量对应的 Slot 就可以交给其他变量使用。

局部变量不会像前面介绍的类变量那样存在“准备阶段”。

### 操作数栈

也常称操作栈，它是一个后入先出栈。同局部变量表一样，操作数栈的最大深度也在编译的时候写入 Code 属性的 max_stacks 数据项中。操作数栈的每一个元素可以是任意的 Java 数据类型，包括 long 和 double。32 位数据类型所占的栈容量为 1，64 位数据类型所占的栈容量为 2。在方法执行的时候，操作栈的深度都不会超过 max_stcaks 数据项中设定的最大值。

当一个方法开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作作数栈中写入和提取内容，也就是出栈/入栈操作。操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，在编译程序代码的时候，编译器要严格保证这一点，在类校验阶段的数据流分析中还要再次验证这一点。

在概念模型中，两个栈帧作为虚拟机栈的元素，是完全独立的。但在大多数虚拟机的实现里都会做一些优化处理，令两个栈帧出现一部分重叠。让下面栈帧的部分操作数栈与上面栈帧的局部变量表重叠在一起，这样在进行方法调用的时候就可以共用一部分数据，无须进行额外的参数复制传递。

### 动态连接

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。Class 文件的常量池中存有大量的符号引用，字节码中的方法调用指令就是以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转换为直接引用，这种转化为静态解析。另外一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。

### 方法返回地址

当一个方法开始执行后，只有两种方式可以退出这个方法。第一种是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口

另一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是 Java 虚拟机内部产生的异常，还是代码中使用 athrow 字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为异常完成出口。一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。

无论是何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的 PC 计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。

方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表何操作数栈，把返回值（如果有的话）压入调用者的操作数栈中，调整 PC 计数器的值以指向方法调用指令后面的一条指令。

## 方法调用

方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。

### 解析

所有方法调用中的目标方法在 Class 文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。这类方法的调用称为解析。

在 Java 中符合“编译期可知，运行期不可变”这个要求的方法，最主要包括静态方法和私有方法两大类，它们都适合在类加载阶段进行解析。

### 分派

1. 静态分配

  虚拟机（准确的说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判断依据的。并且静态类型是编译器可知的，因此，在编译阶段，Javac 编译器会根据参数的静态类型决定使用哪个重载版本。

  所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的典型应用是方法重载。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。另外，编译器虽然能确定出方法的重载版本，但是很多情况下这个重载版本并不是“唯一的”，往往只能确定一个“更加合适的”版本。


2. 动态分派

  invokevirtual 指令的运行时解析过程如下：

  1. 找到操作数栈顶的第一个元素所指向的对象的实际类型，记作 C
  2. 如果在类型 C 中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回 java.lang.IllegalAccessError 异常
  3. 否则，按照继承关系从下往上依次对 C 的各个父类进行第二步的搜索和验证过程。
  4. 如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodError 异常。

3. 单分派与多分派

  方法的接收者和方法的参数统称为方法的宗量。根据分派基于多少种宗量，可以将分派划分成单分派和多分派两种。

  单分派是根据一个宗量对目标进行选择，多分派则是根据多于一个宗量对目标方法进行选择。

  Java 是一门静态多分派、动态单分派的语言。

#### 虚拟机动态分派的实现

为类在 **方法区** 建立一个虚方法表（与此对应的，在 invokeinterface 执行时，也会用到接口方法表），使用虚方法表来代替元数据查找以提高性能。

虚方法表中存放着各个方法阿德实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表中里面的地址入口和父类相同方法的地址入口是一样的，都指向父类的实现入口。如果子类重写了这个方法，子类方法表中的地址将会替换为指向子类实现版本的入口地址。

为了程序实现上的方便，具有相同方法签名的方法，在父类、子类的虚方法表中都应该有一样的索引序号。

方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始化值后，虚拟机会把该类的方法表也初始化完毕。

## 基于栈的字节码解释引擎

Java 编译器输出的指令流，基本上是一种基于栈的指令集架构，指令流中的指令大部分都是零地址指令，它们依赖操作数栈进行工作。

基于栈的指令集主要的优点就是可移植，但是执行速度会稍慢一些。
