# 垃圾收集器与内存分配策略

程序计数器、虚拟机栈、本地方法栈 3 个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的。因此这几个区域的内存分配和回收都具备确定性，这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟着回收了。而 Java 堆和方法区则不一样，一个接口中多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，只有在程序处于运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器关注的是这部分内存。

## 如何判断对象“已死”

### 引用计数算法

给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加 1；当引用失效时，计数器值就减 1；任何时刻计数器为 0 的对象就是不可能再被使用的。

**难以解决对象之间循环引用的问题。**

### 可达性分析算法

通过一系列的称为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。

在 Java 语言中，可作为 GC Roots 的对象包括下面几种：

* 虚拟机栈

* 方法区中类静态属性引用的对象

* 方法区中常量引用的对象

* 本地方法栈中 JNI （即一般说的 Native 方法）引用的对象

### 引用

* 强引用就是在程序代码之中普遍存在的，类似 `Object obj = new Object()` 这类的引用。

* 软引用，对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。（SoftReference 可以实现软引用）

* 弱引用，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。（WeakReference 可以实现弱引用）

* 虚引用，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。（PhantomReference 可以实现虚引用）

### `finalize()`

即使在可达性算法中不可达的对象，也“并不是非死不可”的，这时候它们是处于“缓刑”阶段的，要真正宣告一个对象死亡，至少要经过两次标记过程。

如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 `finalize()` 方法。当对象没有覆盖 `finalize()` 方法，或着 `finalize()` 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。

如果这个对象被判定有必要执行 `finalize()` 方法，那么这个对象将会被放置在一个叫做 F-Queue 的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程区执行它。

一个对象的 `finalize()` 方法只会被自动自动调用一次。

### 回收方法区

被称为永久代，垃圾收集效率很低

永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类

类需要同时满足下面 3 个条件才能算是 “无用的类”：
1. 该类所有的实例已经被回收，也就是 Java 堆中不存在该类的任何实现

2. 加载该类的 ClassLoader 已经被回收

3. 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

## 垃圾收集算法
